<!DOCTYPE html> 
<html> 
   <header>   
        <meta http-equiv="content-type" content="text/html;charset=utf-8" /> 
        <script>       
			function simplify() {
				var expression = document.getElementById("expression");   
                var result = "";
                // Error handle if not balanced brackets 
				if (!balancedBrackets(expression.value))
				{
					result = "ERROR! There's a bracket error";
				}
				else {				
                    // Split based on operations 
                    var charArray = expression.value.replace(/\s/g,'').split('');

                    // Convert infix to postfix 
                    var postfix = InfixToPostfix(charArray);
                    var charPostfix = postfix.split('');

                    // Put postfix into an expression tree 
                    var expressionTree = createExpressionTree(charPostfix);
                    console.log(expressionTree);
                    inorder(expressionTree);    
                    
                    // Output simplified expression 
                    var simplifiedExpression = document.getElementById("simplifiedExpression");  
                    simplifiedExpression.value = postfix;
                }
            }

            /* Methods for Infix to Postfix conversion */
            function pushArray(stackArr,ele)
            {
                stackArr[stackArr.length]=ele;
            }

            function popArray(stackArr)
            {
                var _temp=stackArr[stackArr.length-1];
                delete stackArr[stackArr.length-1];
                stackArr.length--;
                return(_temp);
            }

            function isOperand(x)
            {
                return((!isOperator(x) && (x!="(") && (x!=")")) ? true : false);
            }

            function isOperator(x)
            {
                return((x =="+" || x =="-" || x =="*" || x =="/" || x =="^") ? true : false);
            }

            function peekArray(stackArr)
            {
                return(stackArr[stackArr.length-1]);
            }

            function isEmpty(stackArr)
            {
                return((stackArr.length==0)? true : false);
            }

            /* Check for precedence */
            function precedence(x)
            {
                if(x=="^")
                    return(5);
                if((x=="*")||(x=="/"))
                    return(4);
                if((x=="+")||(x=="-"))
                    return(3);
                if(x=="(")
                    return(2);
                if(x==")")
                    return(1);
            }

            function InfixToPostfix(infixStr)
            {
                var postfixStr=new Array();
                var stackArr=new Array();
                var postfixPtr=0;
                infixStr = strToTokens(infixStr);

                for(var i=0; i<infixStr.length; i++)
                {        
                    if (infixStr[i] == " ") {

                    }
                    else if(isOperand(infixStr[i]))
                    {
                        postfixStr[postfixPtr]=infixStr[i];
                        postfixPtr++;
                    }
                    else if(isOperator(infixStr[i]))
                    {
                        if(infixStr[i]!="^")
                        {
                            while((!isEmpty(stackArr)) && (precedence(infixStr[i])<=precedence(peekArray(stackArr))))
                            {
                                postfixStr[postfixPtr]=peekArray(stackArr);
                                popArray(stackArr);
                                postfixPtr++;
                            }
                        }
                        else
                        {
                            while((!isEmpty(stackArr)) && (precedence(infixStr[i])<precedence(peekArray(stackArr))))
                            {
                                postfixStr[postfixPtr]=peekArray(stackArr);
                                popArray(stackArr);
                                postfixPtr++;
                            }
                        }
                     pushArray(stackArr,infixStr[i]);
                    }
                    
                    if(infixStr[i]=="(") {
                     pushArray(stackArr,infixStr[i]);
                    }
                    else if(infixStr[i]==")")
                    {
                        while(peekArray(stackArr)!="(")
                        {
                            postfixStr[postfixPtr]=popArray(stackArr);
                            postfixPtr++;
                        }
                        popArray(stackArr);
                    }
                }
                
                while(!isEmpty(stackArr))
                {
                    if(peekArray(stackArr)=="(")
                        popArray(stackArr)
                    else
                        postfixStr[postfixStr.length]=popArray(stackArr);
                }
                
                var val='';
                for(var i=0; i < postfixStr.length; i++)
                {
                    val += postfixStr[i];
                }
                return(val);
            }

            function strToTokens(strArr)
            {
                var tempStr=new String("");	
                var tokens=new Array();
                var tokens_index=0;
                
                for(var i=0; i<strArr.length; i++)
                {
                    if(isOperand(strArr[i]))
                    {
                        tempStr+=strArr[i];
                    }
                    
                    if(isOperator(strArr[i]) || strArr[i]==")" || strArr[i]=="(")
                    {
                        if(tempStr!="")
                        {
                            tokens[tokens_index]=tempStr;
                            tokens_index++;
                        }
                        tempStr="";
                        tokens[tokens_index]=strArr[i];
                        tokens_index++;
                    }
                    
                    if(i==strArr.length-1)
                        if(tempStr!="")
                            tokens[tokens_index]=tempStr;
                }
                return(tokens);
            }

            // Checks if brackets are balanced 
			function balancedBrackets(str) {
				var depth = 0;
				for (var i in str) {
					if (str[i] == '(') {
						depth++; 
					} else if (str[i] == ')') {
						depth--;
					}
					
					if (depth < 0) {
						return false; 
					}
				}
				if (depth > 0) {
					return false;
				}
				return true;
			};

            /* Methods for Expression Tree */
            function createExpressionTree(postfix) {
                var result = new Stack();

                for (var i = 0; i < postfix.length; i++) {
                    var element = postfix[i];  
                    if (isOperator(element)) {
                        var t = new TreeNode(element);
                        result.push(t);
                    } 
                    else {
                        var t = new TreeNode(element);
                        // If operator, push to stack 
                        // Pop two top nodes, store the top 
                        var t1 = result.pop();
                        var t2 = result.pop();

                        // Add them as children
                        t.right = t1;
                        t.left = t2;
                        result.push(t);                        
                    }
                }
                var t = result.peek();                
                result.pop();
                return t;
            }

            function inorder(node) {
                if (node) {
                    inorder(node.left);
                    console.log(node.value);
                    inorder(node.right);
                }
            }

            function ExpressionTree(postfix) {
                this.postfix = postfix;
            }

            function TreeNode(value) {
                this.value = value;
                this.left = null;
                this.right = null; 
            }        

            // Creates a stack
            var Stack = function() {
                this.count = 0;
                this.storage = {};
            }

            // Adds a value onto the end of the stack
            Stack.prototype.push = function(value) {
                this.storage[this.count] = value;
                this.count++;
            }

            // Removes and returns the value at the end of the stack
            Stack.prototype.pop = function() {
                // Check to see if the stack is empty
                if (this.count === 0) {
                    return undefined;
                }

                this.count--;
                var result = this.storage[this.count];
                delete this.storage[this.count];
                return result;
            }

            // Returns the length of the stack
            Stack.prototype.size = function() {
                return this.count;
            }

            // Gets first node
            Stack.prototype.peek = function() {
                return this.storage[this.count-1];
            }



// Methods commented out from previous exercise # 1 
/*           
            // Return true if letter/char
			function isLetter(str) {
			  return str.length === 1 && str.match(/[a-z]/i);
			};
			// Return true if an operator 
			function isOperator(x) {
				switch(x) {
					case '~':
					case '+':
					case '.':
					case '*':
					case '(':
					case ')':
						return true;
					default:
						return false; 
				}
            };
			// Stack  
			var Stack = function(){
			  this.top = null;
			  this.size = 0;
			};
			// Node
			var Node = function(data){
			  this.data = data;
			  this.previous = null;
			};
			// Push in Stack 
			Stack.prototype.push = function(data) {
			  var node = new Node(data);
			  node.previous = this.top;
			  this.top = node;
			  this.size += 1;
              return this.top;
                
			};
			// Pop in Stack 
			Stack.prototype.pop = function() {
			  temp = this.top;
			  this.top = this.top.previous;
			  this.size -= 1;
			  return temp;
			};
			// Check if Stack is empty 
			Stack.prototype.isEmpty = function() {
				if (this.size > 0) {
					return false;
				}
				return true;
            }
            // Peek to get first item 
            Stack.prototype.peek = function() {
                return this.top;
            } 
			// Check for possible simplifications 
			function checkPossibleSimp(a, b, operator) {
				//0. Commutative law (done because of stack popping order)
				//1. Idempotent law
				if (a == b && (operator == '*' || operator == '+')) {
					return a;
				} 
				//2. Identity law (a * 0 = 0)
				else if ((a == '0' || b == '0') && operator == '*') {
					return '0';
				}
				//3. Identity law (a + 0 = a)
				else if (((a == '0' && b != '0') || (a != '0' && b == '0')) && operator == '+') {
					return a == '0' ? b : a;
				}
				//4. Identity law (a + 1 = 1)
				else if ((a == '1' || b == '1') && operator == '+') {
					return '1';
				}
				//5. Identity law (a * 1 = a)
				else if (((a == '1' && b != '1') || (a != '1' && b == '1')) && operator == '*') {
					return a == '1' ? b : a;
				}	
				// 6. Complement Law 
				else if (a.match(/[~]/) || b.match(/[~]/)) {
					// Complement Law (A*~A = 0)
					if (operator == '*') {
						return 0;
					}
					// Complement Law (A+~A = 0)
					else {
						return 1;
					}
				}
				else {
					return a + operator + b;
				}
            };

            /* This is part of method in SIMPLIFY, commented it out 
					// Convert postfix to result				
                    //var resultStack = new Stack();

                //     // Simplify 
				// 	for (var i = postfix.length - 1; i >= 0; i--) {
				// 		//char is not operator yet
				// 		if (!isOperator(postfix[i])) {
				// 			// 7. Involution Law  
				// 			// If ~(~A)
				// 			if (postfix[i-2] == '~' && postfix[i-1] == '~') {
				// 				resultStack.push(postfix[i]);
				// 			}			
				// 			// If (~A+A)
				// 			else if (postfix[i-2] == '~' && postfix[i-1] != '~' && isOperator(postfix[i-1])) {
				// 				var val = postfix[i-2] + postfix[i];
				// 				resultStack.push(val);
				// 			}	
				// 			// If (A+~A)
				// 			// If it's a ~, then push both into one value (like be ~A for example) 
				// 			else if (postfix[i-2] != '~' && postfix[i-1] == '~') {
				// 				var val = postfix[i-1] + postfix[i];
				// 				resultStack.push(val);
				// 			}
				// 			else {
				// 				resultStack.push(postfix[i]);
				// 			}
				// 		} 
				// 		else if (postfix[i] == '~') {
				// 			// do nothing 
				// 		}
				// 		else {
				// 			var a = resultStack.pop().data;
				// 			var b = resultStack.pop().data;
									
				// 			var simplified = checkPossibleSimp(a, b, postfix[i]);
				// 			if ((simplified == a + postfix[i] + b) || i == 0) {
				// 				result += simplified;
				// 			} 
				// 			else if (simplified == 0 || simplified == 1) {
				// 				result += simplified;
				// 			}
				// 			else {
				// 				resultStack.push(postfix);
				// 			}
				// 		}
				// 	}
*/

		</script>   
	</header>   
	<body style="text-align:center">   
		<h1 id="test" onclick="changeText()">My SYDE 322 test script</h1> 
		<script>   
			document.getElementById("test").innerHTML = "SYDE 322 - Application Exercise"; 
		</script>   
		<p>
			<p>Input your math expression here: </p>
			<input type = "text" style="width: 270px;height: 30px; font-size: 20px" id="expression" value = "" />
			<button type="button" style="height: 30px; font-size: 20px; color: green" onclick="simplify()"/>Simplify</button>
			<p>Simplified Expression: </p>
			<input type = "text" style="width: 400px;height: 30px; font-size: 20px" id="simplifiedExpression" value = "" />
		</p>
	</body>  
</html> 
